1. Using JC69 and K80 have some limitations with very dissimilar sequences since there is a probability that the argument of logarithm will be less than 0, which is not accaptable. For example, if we try to calculate JC69 for AACTCA and TTAGTG, we get H = 6, L = 6, 1 - (4/3) * H / L = -1/3, so we cannot use a logarithm here. The similar case for K80, S = 2/6, V = 4/6, 1 - 2 * s - v = 1 - 4/6 - 4/6 = -2/6 and 1 - 2 * v = -2/6, both values are not acceptable.
2. In my implementation, we use the minimum value that was met first, so the results depend on a sequence of input sequences. Because of that, the output might look different, and I guess the whole structure might be different.
3. The first reason is that the pairwise distances matrix does not in general correspond to any ultrametric tree, so the algorithm tries to reconstruct the tree as well as possible. So, if there is a tree that perfectly matches the initial distances, the UPGMA finds it.
The second reason is the UPGMA is appropriate with some assumptions, to be more specific if all sequences are sampled at the same point in time and evolved according to a strict molecular clock. Then genetic distance will coincide in the distance matrix and ultrametric tree where branch lengths are proportional to calendar time.
4. If the assumptions mentioned in 3 are violated, the neighbor-joining algorithm may be used instead to reconstruct a non-ultrametric tree. The algorithm is quite similar to UPGMA, it works iteratively by pairing nodes and joining them together. The main difference is inferring unrooted trees with branch lengths in units of a number of substitutions.
